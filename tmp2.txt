# Project Overview

### Project theme

Students are free to **select any project scenario or application domain** of their choice. This could be a utility, a simulation, a personal productivity tool, a data processing tool, or anything else that fits the criteria.

> **The minimum required features must be implemented as specified.**
> 

Students may integrate **any number of advanced technologies** or design patterns from the optional list to improve their score.

Projects will be evaluated not just on what is included, but how well technologies are integrated, justified, and secured.

**Develop** a well-architected, secure, and maintainable Java SE **application** showcasing object-oriented design, use of patterns, and **core Java technologies**.

### Minimum requirements

- **4 Required Design Patterns:** Factory, Composite, Iterator, Exception Shielding
- **Core Technologies:** Collections, Generics, Java I/O, Logging, JUnit Testing
- **Secure Programming:** Input Sanitization, No Hardcoded Secrets, Controlled Exception Propagation

### Additional requirements

**Beyond Minimum**

- Additional patterns and technologies from a defined list.
- Correct integration and critical-path usage of optional components.
- Additional points do not raise the grade beyond 50, but allow varied strategy.

**Security Penalties**

- Crashes, stack traces, insecure data handling will subtract points.

**Documentation and Justification**

- README must include project overview, design decisions, diagrams,
- tech/pattern justifications, limitations.
- Expect interview questions on alternatives and rationale.

### deliverables

1. Complete Java project source code
2. README.md with:
    1. Application overview and functionality
    2. Technologies and patterns used, with justification
    3. Setup and execution instructions
    4. UML diagrams (class + architectural)
    5. Known limitations and future work
3. Test suite

### interview

During the evaluation, you will:

1. Demo your application live
2. Walk through random parts of the code
3. Justify your design decisions

Expect questions on why specific technologies and patterns were used over alternatives. Your understanding and rationale are part of your grade.

## Evaluation

### Required feature

| Design Patterns  | 16 pt |
| --- | --- |
| Factory  | 3 pt |
| Composite  | 3 pt |
| Iterator | 3 pt |
| Exception Shielding  | 5 pt |

| Technologies | 14 pt |
| --- | --- |
| Collections Framework  | 3 pt |
| Generics | 3 pt |
| Java I/O  | 3 pt |
| Logging | 2 pt |
| Logging | 3 pt |

All these items are required: (you must include all of them in your project)

Each item coding and usage will be evaluated from 0 to N points.

You must obtain a minimum of 25 points from these items. (not everything must be perfect)

### Optional Advanced Features

| Technologies |  |
| --- | --- |
| Multithreading | 8 pt |
| Stream API & Lambdas  | 5 pt |
| Reflection | 4 pt  |
| Inversion of Control | 5 pt |
| Custom Annotations  | 2 pt |
| Custom Annotations  | 3 pt |

| Design Patterns |  |
| --- | --- |
| Abstract Factory  | 3 pt |
| Builder | 3 pt |
| Strategy | 4 pt |
| Observer | 5 pt |
| Chain of Responsibility  | 4 pt |
| Adapter/Bridge/Proxy/Decorator  | 2 pt each |
| Singleton  | 2 pt |
| Memento | 3 pt |
| Template Method | 3 pt |

### Security Penalties

- Stack traces visible to users: -5 pts
- Application crashes on invalid input: -5 pts
- Hardcoded credentials: -3 pts
- No input sanitization: -3 pts
Exception propagation leaks: -3 pts
- Poor logging practices: -2 pts
- Minor issues: -1 pt each

### Final grade

Final grade will be calculated as follow:

requied features + optional feature - security penalties

**Minimum grade to approve the project is 25 points.
Maximum grade obtained with at least 50 points.**


my code untill now:

//annotations/autoload.java
package manfrinmarco.annotations;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface AutoLoad {}

//config/gameconfig.java
package manfrinmarco.config;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

public class GameConfig {
    private static final Properties config = new Properties();

    static {
        try (FileInputStream fis = new FileInputStream("game.properties")) {
            config.load(fis);
        } catch (IOException e) {
            System.err.println("Errore caricamento configurazione: " + e.getMessage());
        }
    }

    public static String get(String key) {
        String value = config.getProperty(key);
        if (value == null) {
            throw new manfrinmarco.security.GameException("Chiave di configurazione mancante: " + key);
        }
        return value;
    }

    public static int getInt(String key) {
        return Integer.parseInt(get(key));
    }

    public static boolean getBoolean(String key) {
        return Boolean.parseBoolean(get(key));
    }

    public static double getDouble(String key) {
        return Double.parseDouble(get(key));
    }

    public static String getOrDefault(String key, String defaultValue) {
        return config.getProperty(key, defaultValue);
    }
} 

//core/abstractcommandprocessor.java
package manfrinmarco.core;

import manfrinmarco.io.InputSanitizer;

public abstract class AbstractCommandProcessor {
    public final void processCommand(String input) {
        String sanitized = sanitizeInput(input);
        String[] tokens = parseCommand(sanitized);
        executeCommand(tokens);
    }

    protected String sanitizeInput(String input) {
        return InputSanitizer.clean(input);
    }

    protected String[] parseCommand(String input) {
        return input.trim().split("\\s+");
    }

    protected abstract void executeCommand(String[] tokens);
}

//core/commandprocessor.java
package manfrinmarco.core;

import manfrinmarco.entities.Enemy;
import manfrinmarco.entities.Player;
import manfrinmarco.events.GameEvent;
import manfrinmarco.items.CompositeItem;
import manfrinmarco.items.Inventory;
import manfrinmarco.items.Item;
import manfrinmarco.items.ItemType;
import manfrinmarco.map.CompositeRoom;
import manfrinmarco.map.Direction;
import manfrinmarco.map.Room;

public class CommandProcessor extends AbstractCommandProcessor {
    private final GameContext context = GameContext.getInstance();

    @Override
    protected void executeCommand(String[] tokens) {
        if (tokens.length == 0) return;
        String command = tokens[0].toLowerCase();

        switch (command) {
            case "guarda" -> lookAround();
            case "muovi" -> {
                if (tokens.length < 2) {
                    System.out.println("Dove vuoi andare?");
                } else {
                    moveTo(tokens[1]);
                }
            }
            case "attacca" -> attack();
            case "stato" -> showStatus();
            case "inventario" -> showInventory();
            case "usa" -> {
                if (tokens.length < 2) {
                    System.out.println("Specifica l'oggetto da usare.");
                } else {
                    useItem(tokens[1]);
                }
            }
            case "equip" -> {
                if (tokens.length < 2) {
                    System.out.println("Specifica cosa vuoi equipaggiare.");
                } else {
                    equipItem(tokens[1]);
                }
            }
            case "prendi" -> {
                if (tokens.length < 2) {
                    System.out.println("Specifica cosa vuoi prendere.");
                } else {
                    pickItem(tokens[1]);
                }
            }
            // case "salva" -> manfrinmarco.io.GameFileManager.saveContext(context);
            // case "carica" -> {
            //     GameContext loaded = manfrinmarco.io.GameFileManager.loadContext();
            //     if (loaded != null) {
            //         context.copyFrom(loaded);
            //         System.out.println("Partita caricata.");
            //         lookAround();
            //     }
            // }
            case "esplora" -> exploreRooms();
            case "combina" -> {
                if (tokens.length < 3) {
                    System.out.println("Specifica due oggetti da combinare.");
                } else {
                    combineItems(tokens[1], tokens[2]);
                }
}
            default -> System.out.println("Comando sconosciuto.");
        }
    }

    private void lookAround() {
        Room room = context.getCurrentRoom();
        System.out.println("Ti trovi in: " + room.getName());
        System.out.println(room.getDescription());
        for (Direction dir : Direction.values()) {
            if (room.getExit(dir) != null) {
                System.out.println("C'è un passaggio a " + dir.name().toLowerCase());
            }
        }
        if (room.getEnemy() != null && room.getEnemy().isAlive()) {
            System.out.println("Un nemico è qui: " + room.getEnemy().getName());
            if (room.getEnemy().getStrategy() instanceof manfrinmarco.entities.AggressiveStrategy) {
                System.out.println("Il " + room.getEnemy().getName() + " ti coglie di sorpresa!");
                room.getEnemy().executeStrategy(context.getPlayer());
                System.out.println("Hai subito un attacco! HP attuali: " + context.getPlayer().getHealth());
            }
        }
        if (!room.getItems().isEmpty()) {
            System.out.println("Oggetti nella stanza:");
            for (Item item : room.getItems()) {
                System.out.println("- " + item.getName());
            }
        }
    }

    private void moveTo(String dirString) {
        try {
            Direction dir = Direction.valueOf(dirString.toUpperCase());
            Room current = context.getCurrentRoom();
            Room next = current.getExit(dir);
            if (next != null) {
                context.setCurrentRoom(next);
                Enemy enemy = next.getEnemy();
                if (enemy != null && enemy.isAlive() && enemy.getStrategy() instanceof manfrinmarco.entities.AggressiveStrategy) {
                    System.out.println("Il " + enemy.getName() + " ti coglie di sorpresa!");
                    enemy.executeStrategy(context.getPlayer());
                    System.out.println("Hai subito un attacco! HP attuali: " + context.getPlayer().getHealth());
                    if (!context.getPlayer().isAlive()) {
                        System.out.println("Sei morto! Game Over.");
                        System.exit(0);
                    }
                }
                System.out.println("Ti muovi verso " + dir.name().toLowerCase());
                lookAround();
            } else {
                System.out.println("Non c'è nulla in quella direzione.");
            }
        } catch (IllegalArgumentException e) {
            System.out.println("Direzione non valida.");
        }
    }

    private void attack() {
        Enemy enemy = context.getCurrentRoom().getEnemy();
        Player player = context.getPlayer();
        if (enemy == null || !enemy.isAlive()) {
            System.out.println("Non c'è nessun nemico da attaccare.");
            return;
        }
        player.attack(enemy);
        System.out.println("Hai attaccato il " + enemy.getName() + ". HP rimanenti: " + enemy.getHealth());
        if (enemy.isAlive()) {
            enemy.executeStrategy(player);
            System.out.println("Il " + enemy.getName() + " ti attacca! HP rimanenti: " + player.getHealth());
            if (!player.isAlive()) {
                System.out.println("Sei morto! Game Over.");
                System.exit(0);
            }
        } else {
            System.out.println("Hai sconfitto il " + enemy.getName() + "!");
            context.getEventManager().notify(new GameEvent("enemy_defeated", "Hai sconfitto un nemico!"));
        }
    }

    private void showStatus() {
        Player player = context.getPlayer();
        System.out.println("HP: " + player.getHealth());
    }

    private void showInventory() {
        System.out.println("Inventario:");
        for (Item item : context.getPlayer().getInventory()) {
            System.out.println("- " + item.getName());
        }
    }

    private void useItem(String itemName) {
        Inventory inventory = context.getPlayer().getInventory();
        for (Item item : inventory) {
            if (item.getName().equalsIgnoreCase(itemName.trim())) {
                if (item.getType() == ItemType.POTION) {
                    int healAmount = 20;
                    try {
                        healAmount = Integer.parseInt(manfrinmarco.config.GameConfig.get("item.potion.healAmount"));
                    } catch (Exception e) {
                        System.err.println("Valore di healAmount non valido, uso 20 di default.");
                    }
                    context.getPlayer().heal(healAmount);
                    System.out.println("Hai usato " + item.getName() + " e recuperato " + healAmount + " HP.");
                    inventory.removeItem(item);
                    return;
                }
                if (item.getType() == ItemType.KEY) {
                    Room room = context.getCurrentRoom();
                    for (Direction dir : Direction.values()) {
                        Room adjacent = room.getExit(dir);
                        if (adjacent != null && adjacent.isLocked() && adjacent.unlock(item)) {
                            System.out.println("Hai sbloccato la stanza a " + dir.name().toLowerCase() + ".");
                            inventory.removeItem(item);
                            return;
                        }
                    }
                    System.out.println("Nessuna porta è stata sbloccata.");
                    return;
                }
                System.out.println("Hai usato " + item.getName() + ".");
                inventory.removeItem(item);
                return;
            }
        }
        System.out.println("Oggetto non trovato.");
    }

    private void equipItem(String itemName) {
        Inventory inventory = context.getPlayer().getInventory();
        for (Item item : inventory) {
            if (item.getName().equalsIgnoreCase(itemName)) {
                context.getPlayer().equip(item);
                return;
            }
        }
        System.out.println("Oggetto non trovato o non equipaggiabile.");
    }

    private void pickItem(String itemName) {
        Room room = context.getCurrentRoom();
        for (Item item : room.getItems()) {
            if (item.getName().equalsIgnoreCase(itemName)) {
                context.getPlayer().getInventory().addItem(item);
                room.removeItem(item);
                System.out.println("Hai raccolto: " + item.getName());
                return;
            }
        }
        System.out.println("Oggetto non trovato nella stanza.");
    }

    private void exploreRooms() {
        Room current = context.getCurrentRoom();

        // Se ci troviamo nella stanza principale di una CompositeRoom
        if (current instanceof CompositeRoom composite) {
            System.out.println("Stanze interne di " + composite.getName() + ":");
            for (Room room : composite.getSubRooms()) {
                System.out.println("- " + room.getName());
            }
        } else {
            // Proviamo a vedere se la stanza corrente appartiene a una CompositeRoom
            CompositeRoom parent = findParentComposite(current);
            if (parent != null) {
                System.out.println("Stanze interne di " + parent.getName() + ":");
                for (Room room : parent.getSubRooms()) {
                    System.out.println("- " + room.getName());
                }
            } else {
                System.out.println("Stanze collegate:");
                if (current != null) {
                    for (Direction dir : Direction.values()) {
                        Room adjacent = current.getExit(dir);
                        if (adjacent != null) {
                            System.out.println("- " + dir.name().toLowerCase() + ": " + adjacent.getName());
                        }
                    }
                } else {
                    System.out.println("Errore: stanza corrente non trovata.");
                }
            }
        }
    }

    private CompositeRoom findParentComposite(Room room) {
        // Se GameContext contiene una CompositeRoom come mappa principale
        Room parent = GameContext.getInstance().getCurrentRoom();
        if (parent instanceof CompositeRoom composite) {
            for (Room sub : composite.getSubRooms()) {
                if (sub == room) return composite;
            }
        }
        return null;
    }
    
    private void combineItems(String name1, String name2) {
        Inventory inventory = context.getPlayer().getInventory();
        Item item1 = null, item2 = null;

        for (Item item : inventory) {
            if (item.getName().equalsIgnoreCase(name1)) item1 = item;
            else if (item.getName().equalsIgnoreCase(name2)) item2 = item;
        }

        if (item1 == null || item2 == null) {
            System.out.println("Uno o entrambi gli oggetti non sono nell'inventario.");
            return;
        }

        CompositeItem armaCombinata = new CompositeItem("Arma Combinata");
        armaCombinata.addItem(item1);
        armaCombinata.addItem(item2);
        armaCombinata.setPower(item1.getPower() + item2.getPower());

        inventory.removeItem(item1);
        inventory.removeItem(item2);
        inventory.addItem(armaCombinata);

        System.out.println("Hai creato un oggetto combinato: " + armaCombinata.getName());
    }

}

//core/defultgameinitializer
package manfrinmarco.core;

import java.util.List;

import manfrinmarco.config.GameConfig;
import manfrinmarco.entities.Enemy;
import manfrinmarco.entities.EnemyFactory;
import manfrinmarco.entities.Player;
import manfrinmarco.events.ScoreListener;
import manfrinmarco.io.ReflectionLoader;
import manfrinmarco.items.Inventory;
import manfrinmarco.items.Item;
import manfrinmarco.items.ItemBuilder;
import manfrinmarco.items.ItemType;
import manfrinmarco.map.CompositeRoom;
import manfrinmarco.map.Direction;
import manfrinmarco.map.Room;
import manfrinmarco.map.RoomFactory;

public class DefaultGameInitializer {
    public static void initialize(GameContext context) {
        String playerName = GameConfig.get("player.name");
        int playerHealth = Integer.parseInt(GameConfig.get("player.health"));
        Player player = new Player(playerName != null ? playerName : "Eroe", playerHealth > 0 ? playerHealth : 100);
        Inventory inventory = new Inventory();

        Item pozione = new ItemBuilder().setName("Pozione")
                                        .setType(ItemType.POTION)
                                        .setPower(0)
                                        .build();
        inventory.addItem(pozione);
        player.setInventory(inventory);
        context.setPlayer(player);

        // Dungeon composto (CompositeRoom)
        String startRoom = GameConfig.get("start.room");
        Room entrata = RoomFactory.createRoom(startRoom != null ? startRoom : "corridoio");
        Room sala = RoomFactory.createRoom("corridoio");
        Room armeria = RoomFactory.createRoom("armeria");
        Room cripta = RoomFactory.createRoom("cripta");

        entrata.setExit(Direction.NORTH, sala);
        sala.setExit(Direction.SOUTH, entrata);
        sala.setExit(Direction.EAST, armeria);
        armeria.setExit(Direction.WEST, sala);
        sala.setExit(Direction.WEST, cripta);
        cripta.setExit(Direction.EAST, sala);

        CompositeRoom castello = new CompositeRoom("Castello Maledetto", "Un'antica fortezza infestata.");
        castello.addRoom(entrata);
        castello.addRoom(sala);
        castello.addRoom(armeria);
        castello.addRoom(cripta);
        castello.setMainRoom(entrata);
        
        // Nemici
        Enemy goblin = EnemyFactory.createEnemy("goblin");
        goblin.setDrop(new Item("Chiave della Cripta", ItemType.KEY));
        //entrata.setEnemy(goblin);

        Enemy scheletro = EnemyFactory.createEnemy("skeleton");
        scheletro.setDrop(new Item("Spada Rugginosa", ItemType.WEAPON, 10));
        sala.setEnemy(scheletro);

        Enemy guardiano = EnemyFactory.createEnemy("goblin");
        guardiano.setDrop(new Item("Elmo del Guardiano", ItemType.ARMOR, 8));
        cripta.setEnemy(guardiano);

        System.out.println("Caricamento dinamico di oggetti e nemici...");

        List<Object> itemInstances = ReflectionLoader.instantiateAnnotated("manfrinmarco.items.special");
        for (Object obj : itemInstances) {
            if (obj instanceof Item item) {
                System.out.println("Oggetto caricato: " + item.getName());
                inventory.addItem(item);
            }
        }

        List<Object> enemyInstances = ReflectionLoader.instantiateAnnotated("manfrinmarco.entities.custom");
        for (Object obj : enemyInstances) {
            if (obj instanceof Enemy enemy) {
                System.out.println("Nemico caricato: " + enemy.getName());
                // Facoltativo: usarne uno in gioco
                // entrata.setEnemy(enemy); // se vuoi metterlo nella prima stanza
            }
        }

        armeria.addItem(new Item("Scudo di Ferro", ItemType.ARMOR, 6));
        entrata.addItem(new Item("Armatura", ItemType.ARMOR, 10));
        entrata.addItem(new Item("Spada", ItemType.WEAPON, 5));


        context.setCurrentRoom(castello);
        context.setCurrentRoom(castello.getMainRoom() != null ? castello.getMainRoom() : entrata);
        context.getEventManager().subscribe(new ScoreListener());
    }
}

//core/game.java
package manfrinmarco.core;

import java.util.Scanner;

public class Game {
    private final GameContext context = GameContext.getInstance();
    private final CommandProcessor processor = new CommandProcessor();

    public void start() {
        DefaultGameInitializer.initialize(context);

        try (Scanner scanner = new Scanner(System.in)) {
            System.out.println("Benvenuto in Dungeon Explorer!");
            
            while (true) {
                System.out.print("\n> ");
                String input = scanner.nextLine();
                if (input.equalsIgnoreCase("exit")) break;
                processor.processCommand(input);
            }
        }
    }
}

//core/gamecontext.java
package manfrinmarco.core;

import java.io.Serializable;

import manfrinmarco.entities.Player;
import manfrinmarco.events.EventManager;
import manfrinmarco.map.Room;

public class GameContext implements Serializable {
    private static final long serialVersionUID = 1L;
    private static final GameContext instance = new GameContext();

    private Player player;
    private Room currentRoom;
    private int score;
    private final EventManager eventManager = new EventManager();

    private GameContext() {
        // usato solo dal singleton
    }
    
    public static GameContext getInstance() {
        return instance;
    }

    public Player getPlayer() {
        return player;
    }

    public void setPlayer(Player player) {
        this.player = player;
    }

    public Room getCurrentRoom() {
        return currentRoom;
    }

    public void setCurrentRoom(Room currentRoom) {
        this.currentRoom = currentRoom;
    }

    public EventManager getEventManager() {
        return eventManager;
    }

    public void increaseScore(int amount) {
        this.score += amount;
        System.out.println("+" + amount + " punti! Punteggio attuale: " + this.score);
    }

    public int getScore() {
        return score;
    }

    public void copyFrom(GameContext other) {
        this.player = other.player;
        this.currentRoom = other.currentRoom;
        this.score = other.score;
    }

    public GameContext cloneContext() {
        GameContext clone = new GameContext();
        clone.copyFrom(this);
        return clone;
    }
}

//core/gamelogger.java
package manfrinmarco.core;

import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;

public class GameLogger {
    private static final String LOG_FILE = manfrinmarco.config.GameConfig.get("log.file");

    public static void log(String message) {
        try (FileWriter writer = new FileWriter(LOG_FILE, true)) {
            writer.write(LocalDateTime.now() + ": " + message + "\n");
        } catch (IOException e) {
            System.err.println("Errore nel logging: " + e.getMessage());
        }
    }
}

//core/gameStateMemento.java
package manfrinmarco.core;

public class GameStateMemento {
    private final GameContext snapshot;

    public GameStateMemento(GameContext current) {
        this.snapshot = current.cloneContext();
    }

    public GameContext getSnapshot() {
        return snapshot;
    }
}

//entities/aggressivestrategy.java
package manfrinmarco.entities;

import java.util.concurrent.ThreadLocalRandom;

public class AggressiveStrategy implements EnemyStrategy {
    @Override
    public void attack(Enemy enemy, Player player) {
        int damage = ThreadLocalRandom.current().nextInt(10, 21); // 10–20
        System.out.println("Il " + enemy.getName() + " attacca con furia causando " + damage + " danni!");
        player.takeDamage(damage);
    }
}

//entities/defensivestrategy.java
package manfrinmarco.entities;

import java.util.concurrent.ThreadLocalRandom;

public class DefensiveStrategy implements EnemyStrategy {
    @Override
    public void attack(Enemy enemy, Player player) {
        if (enemy.getHealth() < 20) {
            int heal = ThreadLocalRandom.current().nextInt(3, 9); // 3–8
            System.out.println("Il " + enemy.getName() + " si cura di " + heal + " HP!");
            enemy.takeDamage(-heal);
        } else {
            int damage = ThreadLocalRandom.current().nextInt(3, 8); // 3–7
            System.out.println("Il " + enemy.getName() + " colpisce cautamente causando " + damage + " danni.");
            player.takeDamage(damage);
        }
    }
}

//entities/enemy.java
package manfrinmarco.entities;
import manfrinmarco.items.Item;

public class Enemy extends Entity {
    private final EnemyStrategy strategy;

    public Enemy(String name, int health, EnemyStrategy strategy) {
        super(name, health);
        this.strategy = strategy;
    }

    public EnemyStrategy getStrategy() {
        return strategy;
    }

    public void executeStrategy(Player player) {
        strategy.attack(this, player);
    }

    private Item drop;

    public void setDrop(Item drop) {
        this.drop = drop;
    }

    public Item getDrop() {
      return drop;
    }

//entities/enemyfactory.java
// EnemyFactory.java — versione dinamica
package manfrinmarco.entities;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import manfrinmarco.io.ReflectionLoader;

public class EnemyFactory {
    private static final Map<String, Enemy> registry = new HashMap<>();

    static {
        List<Object> loaded = ReflectionLoader.instantiateAnnotated("manfrinmarco.entities.custom");
        for (Object obj : loaded) {
            if (obj instanceof Enemy enemy) {
                String key = enemy.getName().toLowerCase();
                registry.put(key, enemy);
                System.out.println("Enemy registrato: " + key);
            }
        }

        // fallback statici
        registry.put("goblin", new Enemy("Goblin", 30, new AggressiveStrategy()));
        registry.put("skeleton", new Enemy("Scheletro", 25, new DefensiveStrategy()));
        registry.put("ratto", new Enemy("Ratto", 15, new AggressiveStrategy()));
    }

    public static Enemy createEnemy(String type) {
        Enemy base = registry.get(type.toLowerCase());
        if (base == null) throw new IllegalArgumentException("Nemico non trovato: " + type);

        return new Enemy(base.getName(), base.getHealth(), base.getStrategy());
    }
} 

//entities/enemystategy.java
package manfrinmarco.entities;

public interface EnemyStrategy {
    void attack(Enemy enemy, Player player);
}

//entities/entity.java 
package manfrinmarco.entities;

public abstract class Entity {
    protected String name;
    protected int health;

    public Entity(String name, int health) {
        this.name = name;
        this.health = health;
    }

    public String getName() {
        return name;
    }

    public int getHealth() {
        return health;
    }

    public boolean isAlive() {
        return health > 0;
    }

    public void attack(Entity enemy) {
        int baseDamage = 0;
        enemy.takeDamage(baseDamage);
    }

    public void takeDamage(int damage) {
        health = Math.max(0, health - damage);
    }
}

//entities/player.java
package manfrinmarco.entities;

import manfrinmarco.config.GameConfig;
import manfrinmarco.items.Inventory;
import manfrinmarco.items.Item;

public class Player extends Entity {
    private Inventory inventory;
    private Item equippedWeapon;
    private Item equippedArmor;

    public Player(String name, int health) {
        super(name, health);
        this.inventory = new Inventory();
        try {
            this.health = Integer.parseInt(GameConfig.get("player.hp"));
        } catch (NumberFormatException e) {
            System.err.println("Valore di player.hp non valido, uso fallback a 100.");
            this.health = 100;
        }
    }

    @Override
    public void attack(Entity enemy) {
        int baseDamage;
        try {
            baseDamage = Integer.parseInt(GameConfig.get("player.basedamage"));
        } catch (NumberFormatException e) {
            System.err.println("Valore di player.basedamage non valido, uso fallback a 10.");
            baseDamage = 10;
        }
        if (equippedWeapon != null) {
            baseDamage += equippedWeapon.getPower();
        }
        enemy.takeDamage(baseDamage);
    }

    public void heal(int amount) {
        this.health = Math.min(100, this.health + amount);
    }

    public Inventory getInventory() {
        return inventory;
    }

    public void setInventory(Inventory inventory) {
        this.inventory = inventory;
    }

    @Override
    public void takeDamage(int damage) {
        int mitigated = damage;
        if (equippedArmor != null) {
            mitigated = Math.max(0, damage - equippedArmor.getPower());
        }
        super.takeDamage(mitigated);
    }

    public String getStatus() {
        String arma = (equippedWeapon != null) ? equippedWeapon.getName() + " (+" + equippedWeapon.getPower() + ")" : "Nessuna";
        String armatura = (equippedArmor != null) ? equippedArmor.getName() + " (+" + equippedArmor.getPower() + ")" : "Nessuna";
        return String.format("HP: %d | Arma: %s | Armatura: %s", this.health, arma, armatura);
    }

    public void equip(Item item) {
        switch (item.getType()) {
            case WEAPON -> {
                this.equippedWeapon = item;
                System.out.println("Hai equipaggiato l'arma: " + item.getName());
            }
            case ARMOR -> {
                this.equippedArmor = item;
                System.out.println("Hai indossato l'armatura: " + item.getName());
            }
            default -> System.out.println("Questo oggetto non può essere equipaggiato.");
        }
    }
}
    
//entities/customs/... all the classes with @autoload
example:
package manfrinmarco.entities.custom;

import manfrinmarco.annotations.AutoLoad;
import manfrinmarco.entities.DefensiveStrategy;
import manfrinmarco.entities.Enemy;

@AutoLoad
public class Skeleton extends Enemy {
    public Skeleton() {
        super("Scheletro", 20, new DefensiveStrategy());
    }
}


//events/eventListener.java
package manfrinmarco.events;

public interface EventListener {
    void onEvent(GameEvent event);
}

//event/eventManager.java
package manfrinmarco.events;

import java.util.ArrayList;
import java.util.List;

public class EventManager {
    private final List<EventListener> listeners = new ArrayList<>();

    public void subscribe(EventListener listener) {
        listeners.add(listener);
    }

    public void notify(GameEvent event) {
        for (EventListener listener : listeners) {
            listener.onEvent(event);
        }
    }
}

/event/gameevent.java
package manfrinmarco.events;

public class GameEvent {
    private final String type;
    private final String message;

    public GameEvent(String type, String message) {
        this.type = type;
        this.message = message;
    }

    public String getType() {
        return type;
    }

    public String getMessage() {
        return message;
    }
}


//event/ScoreListener
package manfrinmarco.events;

import manfrinmarco.core.GameContext;

public class ScoreListener implements EventListener {
    @Override
    public void onEvent(GameEvent event) {
        if (event.getType().equals("enemy_defeated")) {
            int score = Integer.parseInt(manfrinmarco.config.GameConfig.get("score.enemy.defeated"));
            GameContext.getInstance().increaseScore(score);
        }
    }
}

//io/GameFileManager.java
package manfrinmarco.io;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class GameFileManager {
    private static final String SAVE_FILE = "savegame.dat";

    public static void saveGame(String data) {
        try (FileWriter writer = new FileWriter(SAVE_FILE)) {
            writer.write(data);
            System.out.println("Partita salvata.");
        } catch (IOException e) {
            System.err.println("Errore salvataggio: " + e.getMessage());
        }
    }

    public static String loadGame() {
        try (BufferedReader reader = new BufferedReader(new FileReader(SAVE_FILE))) {
            StringBuilder sb = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                sb.append(line).append("\n");
            }
            System.out.println("Partita caricata.");
            return sb.toString();
        } catch (IOException e) {
            System.err.println("Errore caricamento: " + e.getMessage());
            return null;
        }
    }
}

//io/InputSanitizer.java
package manfrinmarco.io;

public class InputSanitizer {
    public static String clean(String input) {
        return input.replaceAll("[^a-zA-Z0-9\\s]", "");
    }
}

//io/reflectionloader.java
package manfrinmarco.io;

import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

import manfrinmarco.annotations.AutoLoad;

public class ReflectionLoader {
    public static List<Object> instantiateAnnotated(String packageName) {
    List<Object> instances = new ArrayList<>();
    try {
        String path = packageName.replace('.', '/');
        URL root = Thread.currentThread().getContextClassLoader().getResource(path);
        if (root == null) return instances;
        File[] files = new File(root.toURI()).listFiles();
        if (files == null) return instances;

        for (File file : files) {
            if (file.getName().endsWith(".class")) {
                String className = packageName + '.' + file.getName().replace(".class", "");
                Class<?> cls = Class.forName(className);
                if (cls.isAnnotationPresent(AutoLoad.class)) {
                    Object obj = cls.getDeclaredConstructor().newInstance();
                    instances.add(obj);
                }
            }
        }
    } catch (Exception e) {
        System.err.println("Errore durante il caricamento dinamico: " + e.getMessage());
    }
    return instances;
}
}

//items/compositeitem.java
package manfrinmarco.items;

import java.util.ArrayList;
import java.util.List;

public class CompositeItem extends Item {
    private final List<Item> components = new ArrayList<>();

    public CompositeItem(String name) {
        super(name, ItemType.WEAPON);
    }

    public void addItem(Item item) {
        components.add(item);
    }

    public List<Item> getComponents() {
        return components;
    }

    public void setPower(int power) {
    this.power = power;
}
}

//items/inventory.java
package manfrinmarco.items;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Inventory implements Iterable<Item> {
    private final List<Item> items = new ArrayList<>();

    public void addItem(Item item) {
        items.add(item);
    }

    public void removeItem(Item item) {
        items.remove(item);
    }

    @Override
    public Iterator<Item> iterator() {
        return items.iterator();
    }
}

//items/item.java
package manfrinmarco.items;

public class Item {
    protected String name;
    protected ItemType type;
    protected int power;

    public Item(String name, ItemType type) {
        this.name = name;
        this.type = type;
    }

    public Item(String name, ItemType type, int power) {
        this.name = name;
        this.type = type;
        this.power = power;
    }

    @Override
    public String toString() {
        return name + " (" + type + (power > 0 ? ", +" + power : "") + ")";
    }

    public String getName() {
        return name;
    }

    public ItemType getType() {
        return type;
    }

    public int getPower() {
        return power;
    }
}

//items/itembuilder.java
package manfrinmarco.items;

public class ItemBuilder {
    private String name;
    private ItemType type;
    private int power;

    public ItemBuilder setName(String name) {
        this.name = name;
        return this;
    }

    public ItemBuilder setType(ItemType type) {
        this.type = type;
        return this;
    }

    public ItemBuilder setPower(int power) {
        this.power = power;
        return this;
    }

    public Item build() {
        return new Item(name, type, power);
    }
}

//items/itemtype.java
package manfrinmarco.items;

public enum ItemType {
    WEAPON,
    ARMOR,
    POTION,
    KEY,
    TOOL
}

//items/itemfacory.java
package manfrinmarco.items;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import manfrinmarco.io.ReflectionLoader;

public class ItemFactory {
    private static final Map<String, ItemTemplate> registry = new HashMap<>();

    static {
        List<Object> templates = ReflectionLoader.instantiateAnnotated("manfrinmarco.items.templates");
        for (Object obj : templates) {
            if (obj instanceof ItemTemplate template) {
                registry.put(template.getId().toLowerCase(), template);
                System.out.println("Item registrato: " + template.getId());
            }
        }
    }

    public static Item create(String id) {
        ItemTemplate template = registry.get(id.toLowerCase());
        if (template == null) throw new IllegalArgumentException("Item non trovato: " + id);
        return template.create();
    }
}

//items/itemtemplate.java
package manfrinmarco.items;

public interface ItemTemplate {
    Item create();
    String getId(); // es: "spada", "pozione", ecc.
}

//items/special//... all items with @autoload
example:
package manfrinmarco.items.special;

import manfrinmarco.annotations.AutoLoad;
import manfrinmarco.items.Item;
import manfrinmarco.items.ItemBuilder;
import manfrinmarco.items.ItemTemplate;
import manfrinmarco.items.ItemType;

@AutoLoad
public class TorciaMagica implements ItemTemplate {
    @Override
    public Item create() {
        return new ItemBuilder()
                .setName("Torcia Magica")
                .setType(ItemType.TOOL)
                .setPower(0)
                .build();
    }

    @Override
    public String getId() {
        return "torciam";
    }
}


//map/compositeroom.java
package manfrinmarco.map;

import java.util.ArrayList;
import java.util.List;

public class CompositeRoom extends Room {
    private final List<Room> subRooms = new ArrayList<>();

    public CompositeRoom(String name, String description) {
        super(name, description);
    }

    public void addRoom(Room room) {
        subRooms.add(room);
    }

    private Room mainRoom;

    public void setMainRoom(Room room) {
        this.mainRoom = room;
    }

    public Room getMainRoom() {
        return mainRoom;
    }

    public List<Room> getSubRooms() {
        return subRooms;
    }
}

//map/direction
package manfrinmarco.map;

public enum Direction {
    NORTH, SOUTH, EAST, WEST;
}

//map/room.java
package manfrinmarco.map;

import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;

import manfrinmarco.entities.Enemy;
import manfrinmarco.items.Item;

public class Room {
    protected String name;
    protected String description;
    protected Map<Direction, Room> exits = new EnumMap<>(Direction.class);
    protected Enemy enemy;
    protected List<Item> items = new ArrayList<>();
    protected boolean locked = false;
    protected Item keyRequired;

    public Room(String name, String description) {
        this.name = name;
        this.description = description;
    }

    public void setExit(Direction direction, Room room) {
        exits.put(direction, room);
    }

    public Room getExit(Direction direction) {
        return exits.get(direction);
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public Enemy getEnemy() {
        return enemy;
    }

    public void setEnemy(Enemy enemy) {
        this.enemy = enemy;
    }

    public void addItem(Item item) {
        items.add(item);
    }

    public void removeItem(Item item) {
        items.remove(item);
    }

    public List<Item> getItems() {
        return items;
    }

    public boolean isLocked() {
        return locked;
    }

    public void setLocked(boolean locked, Item keyRequired) {
        this.locked = locked;
        this.keyRequired = keyRequired;
    }

    public boolean unlock(Item key) {
        if (locked && keyRequired != null && key.getName().equalsIgnoreCase(keyRequired.getName())) {
            locked = false;
            return true;
        }
        return false;
    }
}

//map/roomfactory.java
package manfrinmarco.map;

public class RoomFactory {
    public static Room createRoom(String type) {
        return switch (type.toLowerCase()) {
            case "corridoio" -> new Room("Corridoio", "Un lungo corridoio buio.");
            case "cella" -> new Room("Cella", "Una piccola cella abbandonata.");
            case "entrata" -> new Room("Entrata", "L'ingresso del castello.");
            case "sala" -> new Room("Sala del Trono", "La grande sala del trono.");
            case "armeria" -> new Room("Armeria Oscura", "Contiene armi abbandonate.");
            case "cripta" -> new Room("Cripta", "Una cripta buia e fredda.");
            default -> new Room("Stanza misteriosa", "Non riesci a distinguere nulla.");
        };
    }
}

//map/roomiterator.java
package manfrinmarco.map;

import java.util.Iterator;
import java.util.List;

public class RoomIterator implements Iterator<Room> {
    private final Iterator<Room> iterator;

    public RoomIterator(List<Room> rooms) {
        this.iterator = rooms.iterator();
    }

    @Override
    public boolean hasNext() {
        return iterator.hasNext();
    }

    @Override
    public Room next() {
        return iterator.next();
    }
}

//security/gameException.java
package manfrinmarco.security;

public class GameException extends RuntimeException {
    public GameException(String message) {
        super(message);
    }
}

//main.java
package manfrinmarco;

import manfrinmarco.core.Game;

public class Main {
    public static void main(String[] args) {
        Game game = new Game();
        game.start();
    }
}

//game.properties
# --------------------------
# Configurazione Giocatore
# --------------------------
player.hp=100
player.baseDamage=10

# --------------------------
# Oggetti
# --------------------------
item.potion.healAmount=20

# --------------------------
# Logging
# --------------------------
log.file=game.log

# --------------------------
# Punteggio
# --------------------------
score.enemy.defeated=100



manca in ordine di priorità:

- Rendere EnemyFactory e ItemFactory dinamiche -> done 
- integrare game config -> done
- Junit test (mockito se serve)
- save / reload status
- mappa demo
- aggiungere logs
- import map from file (json)
- mappa finale