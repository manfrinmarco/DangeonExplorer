my code untill now:

//annotations/autoload.java
package manfrinmarco.annotations;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface AutoLoad {}

//config/gameconfig.java
package manfrinmarco.config;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

public class GameConfig {
    private static final Properties config = new Properties();

    static {
        try (FileInputStream fis = new FileInputStream("game.properties")) {
            config.load(fis);
        } catch (IOException e) {
            System.err.println("Errore caricamento configurazione: " + e.getMessage());
        }
    }

    public static String get(String key) {
        String value = config.getProperty(key);
        if (value == null) {
            throw new manfrinmarco.security.GameException("Chiave di configurazione mancante: " + key);
        }
        return value;
    }

    public static int getInt(String key) {
        return Integer.parseInt(get(key));
    }

    public static boolean getBoolean(String key) {
        return Boolean.parseBoolean(get(key));
    }

    public static double getDouble(String key) {
        return Double.parseDouble(get(key));
    }

    public static String getOrDefault(String key, String defaultValue) {
        return config.getProperty(key, defaultValue);
    }
} 

//core/abstractcommandprocessor.java
package manfrinmarco.core;

import manfrinmarco.io.InputSanitizer;

public abstract class AbstractCommandProcessor {
    public final void processCommand(String input) {
        String sanitized = sanitizeInput(input);
        String[] tokens = parseCommand(sanitized);
        executeCommand(tokens);
    }

    protected String sanitizeInput(String input) {
        return InputSanitizer.clean(input);
    }

    protected String[] parseCommand(String input) {
        return input.trim().split("\\s+");
    }

    protected abstract void executeCommand(String[] tokens);
}

//core/commandprocessor.java
package manfrinmarco.core;

import manfrinmarco.entities.Enemy;
import manfrinmarco.entities.Player;
import manfrinmarco.events.GameEvent;
import manfrinmarco.items.CompositeItem;
import manfrinmarco.items.Inventory;
import manfrinmarco.items.Item;
import manfrinmarco.items.ItemType;
import manfrinmarco.map.CompositeRoom;
import manfrinmarco.map.Direction;
import manfrinmarco.map.Room;

public class CommandProcessor extends AbstractCommandProcessor {
    private final GameContext context = GameContext.getInstance();

    @Override
    protected void executeCommand(String[] tokens) {
        if (tokens.length == 0) return;
        String command = tokens[0].toLowerCase();

        switch (command) {
            case "guarda" -> lookAround();
            case "muovi" -> {
                if (tokens.length < 2) {
                    System.out.println("Dove vuoi andare?");
                } else {
                    moveTo(tokens[1]);
                }
            }
            case "attacca" -> attack();
            case "stato" -> showStatus();
            case "inventario" -> showInventory();
            case "usa" -> {
                if (tokens.length < 2) {
                    System.out.println("Specifica l'oggetto da usare.");
                } else {
                    useItem(tokens[1]);
                }
            }
            case "equip" -> {
                if (tokens.length < 2) {
                    System.out.println("Specifica cosa vuoi equipaggiare.");
                } else {
                    equipItem(tokens[1]);
                }
            }
            case "prendi" -> {
                if (tokens.length < 2) {
                    System.out.println("Specifica cosa vuoi prendere.");
                } else {
                    pickItem(tokens[1]);
                }
            }
            // case "salva" -> manfrinmarco.io.GameFileManager.saveContext(context);
            // case "carica" -> {
            //     GameContext loaded = manfrinmarco.io.GameFileManager.loadContext();
            //     if (loaded != null) {
            //         context.copyFrom(loaded);
            //         System.out.println("Partita caricata.");
            //         lookAround();
            //     }
            // }
            case "esplora" -> exploreRooms();
            case "combina" -> {
                if (tokens.length < 3) {
                    System.out.println("Specifica due oggetti da combinare.");
                } else {
                    combineItems(tokens[1], tokens[2]);
                }
}
            default -> System.out.println("Comando sconosciuto.");
        }
    }

    private void lookAround() {
        Room room = context.getCurrentRoom();
        System.out.println("Ti trovi in: " + room.getName());
        System.out.println(room.getDescription());
        for (Direction dir : Direction.values()) {
            if (room.getExit(dir) != null) {
                System.out.println("C'è un passaggio a " + dir.name().toLowerCase());
            }
        }
        if (room.getEnemy() != null && room.getEnemy().isAlive()) {
            System.out.println("Un nemico è qui: " + room.getEnemy().getName());
            if (room.getEnemy().getStrategy() instanceof manfrinmarco.entities.AggressiveStrategy) {
                System.out.println("Il " + room.getEnemy().getName() + " ti coglie di sorpresa!");
                room.getEnemy().executeStrategy(context.getPlayer());
                System.out.println("Hai subito un attacco! HP attuali: " + context.getPlayer().getHealth());
            }
        }
        if (!room.getItems().isEmpty()) {
            System.out.println("Oggetti nella stanza:");
            for (Item item : room.getItems()) {
                System.out.println("- " + item.getName());
            }
        }
    }

    private void moveTo(String dirString) {
        try {
            Direction dir = Direction.valueOf(dirString.toUpperCase());
            Room current = context.getCurrentRoom();
            Room next = current.getExit(dir);
            if (next != null) {
                context.setCurrentRoom(next);
                Enemy enemy = next.getEnemy();
                if (enemy != null && enemy.isAlive() && enemy.getStrategy() instanceof manfrinmarco.entities.AggressiveStrategy) {
                    System.out.println("Il " + enemy.getName() + " ti coglie di sorpresa!");
                    enemy.executeStrategy(context.getPlayer());
                    System.out.println("Hai subito un attacco! HP attuali: " + context.getPlayer().getHealth());
                    if (!context.getPlayer().isAlive()) {
                        System.out.println("Sei morto! Game Over.");
                        System.exit(0);
                    }
                }
                System.out.println("Ti muovi verso " + dir.name().toLowerCase());
                lookAround();
            } else {
                System.out.println("Non c'è nulla in quella direzione.");
            }
        } catch (IllegalArgumentException e) {
            System.out.println("Direzione non valida.");
        }
    }

    private void attack() {
        Enemy enemy = context.getCurrentRoom().getEnemy();
        Player player = context.getPlayer();
        if (enemy == null || !enemy.isAlive()) {
            System.out.println("Non c'è nessun nemico da attaccare.");
            return;
        }
        player.attack(enemy);
        System.out.println("Hai attaccato il " + enemy.getName() + ". HP rimanenti: " + enemy.getHealth());
        if (enemy.isAlive()) {
            enemy.executeStrategy(player);
            System.out.println("Il " + enemy.getName() + " ti attacca! HP rimanenti: " + player.getHealth());
            if (!player.isAlive()) {
                System.out.println("Sei morto! Game Over.");
                System.exit(0);
            }
        } else {
            System.out.println("Hai sconfitto il " + enemy.getName() + "!");
            context.getEventManager().notify(new GameEvent("enemy_defeated", "Hai sconfitto un nemico!"));
        }
    }

    private void showStatus() {
        Player player = context.getPlayer();
        System.out.println("HP: " + player.getHealth());
    }

    private void showInventory() {
        System.out.println("Inventario:");
        for (Item item : context.getPlayer().getInventory()) {
            System.out.println("- " + item.getName());
        }
    }

    private void useItem(String itemName) {
        Inventory inventory = context.getPlayer().getInventory();
        for (Item item : inventory) {
            if (item.getName().equalsIgnoreCase(itemName.trim())) {
                if (item.getType() == ItemType.POTION) {
                    int healAmount = 20;
                    try {
                        healAmount = Integer.parseInt(manfrinmarco.config.GameConfig.get("item.potion.healAmount"));
                    } catch (Exception e) {
                        System.err.println("Valore di healAmount non valido, uso 20 di default.");
                    }
                    context.getPlayer().heal(healAmount);
                    System.out.println("Hai usato " + item.getName() + " e recuperato " + healAmount + " HP.");
                    inventory.removeItem(item);
                    return;
                }
                if (item.getType() == ItemType.KEY) {
                    Room room = context.getCurrentRoom();
                    for (Direction dir : Direction.values()) {
                        Room adjacent = room.getExit(dir);
                        if (adjacent != null && adjacent.isLocked() && adjacent.unlock(item)) {
                            System.out.println("Hai sbloccato la stanza a " + dir.name().toLowerCase() + ".");
                            inventory.removeItem(item);
                            return;
                        }
                    }
                    System.out.println("Nessuna porta è stata sbloccata.");
                    return;
                }
                System.out.println("Hai usato " + item.getName() + ".");
                inventory.removeItem(item);
                return;
            }
        }
        System.out.println("Oggetto non trovato.");
    }

    private void equipItem(String itemName) {
        Inventory inventory = context.getPlayer().getInventory();
        for (Item item : inventory) {
            if (item.getName().equalsIgnoreCase(itemName)) {
                context.getPlayer().equip(item);
                return;
            }
        }
        System.out.println("Oggetto non trovato o non equipaggiabile.");
    }

    private void pickItem(String itemName) {
        Room room = context.getCurrentRoom();
        for (Item item : room.getItems()) {
            if (item.getName().equalsIgnoreCase(itemName)) {
                context.getPlayer().getInventory().addItem(item);
                room.removeItem(item);
                System.out.println("Hai raccolto: " + item.getName());
                return;
            }
        }
        System.out.println("Oggetto non trovato nella stanza.");
    }

    private void exploreRooms() {
        Room current = context.getCurrentRoom();

        // Se ci troviamo nella stanza principale di una CompositeRoom
        if (current instanceof CompositeRoom composite) {
            System.out.println("Stanze interne di " + composite.getName() + ":");
            for (Room room : composite.getSubRooms()) {
                System.out.println("- " + room.getName());
            }
        } else {
            // Proviamo a vedere se la stanza corrente appartiene a una CompositeRoom
            CompositeRoom parent = findParentComposite(current);
            if (parent != null) {
                System.out.println("Stanze interne di " + parent.getName() + ":");
                for (Room room : parent.getSubRooms()) {
                    System.out.println("- " + room.getName());
                }
            } else {
                System.out.println("Stanze collegate:");
                if (current != null) {
                    for (Direction dir : Direction.values()) {
                        Room adjacent = current.getExit(dir);
                        if (adjacent != null) {
                            System.out.println("- " + dir.name().toLowerCase() + ": " + adjacent.getName());
                        }
                    }
                } else {
                    System.out.println("Errore: stanza corrente non trovata.");
                }
            }
        }
    }

    private CompositeRoom findParentComposite(Room room) {
        // Se GameContext contiene una CompositeRoom come mappa principale
        Room parent = GameContext.getInstance().getCurrentRoom();
        if (parent instanceof CompositeRoom composite) {
            for (Room sub : composite.getSubRooms()) {
                if (sub == room) return composite;
            }
        }
        return null;
    }
    
    private void combineItems(String name1, String name2) {
        Inventory inventory = context.getPlayer().getInventory();
        Item item1 = null, item2 = null;

        for (Item item : inventory) {
            if (item.getName().equalsIgnoreCase(name1)) item1 = item;
            else if (item.getName().equalsIgnoreCase(name2)) item2 = item;
        }

        if (item1 == null || item2 == null) {
            System.out.println("Uno o entrambi gli oggetti non sono nell'inventario.");
            return;
        }

        CompositeItem armaCombinata = new CompositeItem("Arma Combinata");
        armaCombinata.addItem(item1);
        armaCombinata.addItem(item2);
        armaCombinata.setPower(item1.getPower() + item2.getPower());

        inventory.removeItem(item1);
        inventory.removeItem(item2);
        inventory.addItem(armaCombinata);

        System.out.println("Hai creato un oggetto combinato: " + armaCombinata.getName());
    }

}

//core/defultgameinitializer
package manfrinmarco.core;

import manfrinmarco.config.GameConfig;
import manfrinmarco.entities.Enemy;
import manfrinmarco.entities.EnemyFactory;
import manfrinmarco.entities.Player;
import manfrinmarco.events.ScoreListener;
import manfrinmarco.items.Inventory;
import manfrinmarco.items.Item;
import manfrinmarco.items.ItemFactory;
import manfrinmarco.items.ItemType;
import manfrinmarco.map.CompositeRoom;
import manfrinmarco.map.Direction;
import manfrinmarco.map.Room;

public class DefaultGameInitializer {
    public static void initialize(GameContext context) {
        Player player = new Player("Eroe", Integer.parseInt(GameConfig.get("player.hp")));
        Inventory inventory = new Inventory();
        player.setInventory(inventory);
        context.setPlayer(player);

        // Zona 1: Costa
        Room nave = new Room("Nave", "Una vecchia nave attraccata.");
        Room porto = new Room("Porto", "Un porto di legno, bagnato dalle onde.");
        nave.setExit(Direction.NORTH, porto);
        porto.setExit(Direction.SOUTH, nave);
        porto.addItem(new Item("Ascia", ItemType.WEAPON, 5));

        // Zona 2: Giardino
        Room giardino = new Room("Giardino", "Un giardino pieno di vegetazione.");
        porto.setExit(Direction.NORTH, giardino);
        giardino.setExit(Direction.SOUTH, porto);
        giardino.addItem(new Item("Elsa", ItemType.WEAPON, 25));

        Enemy giardinoEnemy = EnemyFactory.createEnemy("demone");
        Item torcia = ItemFactory.create("Torcia");
        giardinoEnemy.setDrop(torcia);
        giardino.setEnemy(giardinoEnemy);

        // Zona 3: Castello
        Room entrata = new Room("Entrata", "Una stanza buia, serve una torcia per esplorare.");
        giardino.setExit(Direction.NORTH, entrata);
        entrata.setExit(Direction.SOUTH, giardino);

        Room guardie = new Room("Stanza delle Guardie", "Una stanza sorvegliata da un nemico.");
        Room armeria = new Room("Armeria", "Contiene armi e armature abbandonate.");
        Room cucina = new Room("Cucina", "Odore di stufato e tre pozioni dimenticate.");
        Room boss = new Room("Stanza del Boss", "Un potente nemico ti aspetta qui.");
        Room uscita = new Room("Uscita", "Hai vinto il gioco! Congratulazioni.");

        entrata.setExit(Direction.NORTH, armeria);
        armeria.setExit(Direction.SOUTH, entrata);

        guardie.setExit(Direction.SOUTH, entrata);
        entrata.setExit(Direction.NORTH, guardie);

        armeria.setExit(Direction.SOUTH, guardie);
        guardie.setExit(Direction.EAST, armeria);

        // Blocco accesso cucina con chiave
        Item chiave = new Item("Chiave della Cucina", ItemType.KEY);
        cucina.setLocked(true, chiave);
        armeria.setExit(Direction.EAST, cucina);
        cucina.setExit(Direction.WEST, armeria);

        // Pozioni nella cucina
        cucina.addItem(new Item("Pozione Curativa 1", ItemType.POTION));
        cucina.addItem(new Item("Pozione Curativa 2", ItemType.POTION));
        cucina.addItem(new Item("Pozione Curativa 3", ItemType.POTION));

        // Accesso boss e uscita
        cucina.setExit(Direction.SOUTH, boss);
        boss.setExit(Direction.NORTH, cucina);
        boss.setExit(Direction.EAST, uscita);

        // Drop torcia già previsto in giardino
        Enemy guardia = EnemyFactory.createEnemy("scheletro");
        guardia.setDrop(chiave);
        guardie.setEnemy(guardia);

        armeria.addItem(new Item("Lama", ItemType.WEAPON, 25));
        armeria.addItem(new Item("Armatura", ItemType.ARMOR, 20));

        Enemy bossEnemy = EnemyFactory.createEnemy("demone");
        boss.setEnemy(bossEnemy);

        // Composizione castello
        CompositeRoom castello = new CompositeRoom("Castello sull'Isola", "Un castello antico e misterioso.");
        castello.addRoom(entrata);
        castello.addRoom(guardie);
        castello.addRoom(armeria);
        castello.addRoom(cucina);
        castello.addRoom(boss);
        castello.addRoom(uscita);
        castello.setMainRoom(entrata);

        // Composizione isola
        CompositeRoom isola = new CompositeRoom("Isola", "Un luogo remoto e pericoloso.");
        isola.addRoom(nave);
        isola.addRoom(porto);
        isola.addRoom(giardino);
        isola.addRoom(castello);
        isola.setMainRoom(nave);

        context.setCurrentRoom(isola.getMainRoom());
        context.getEventManager().subscribe(new ScoreListener());
    }
}



//core/game.java
package manfrinmarco.core;

import java.util.Scanner;

public class Game {
    private final GameContext context = GameContext.getInstance();
    private final CommandProcessor processor = new CommandProcessor();

    public void start() {
        DefaultGameInitializer.initialize(context);

        try (Scanner scanner = new Scanner(System.in)) {
            System.out.println("Benvenuto in Dungeon Explorer!");
            
            while (true) {
                System.out.print("\n> ");
                String input = scanner.nextLine();
                if (input.equalsIgnoreCase("exit")) break;
                processor.processCommand(input);
            }
        }
    }
}

//core/gamecontext.java
package manfrinmarco.core;

import java.io.Serializable;

import manfrinmarco.entities.Player;
import manfrinmarco.events.EventManager;
import manfrinmarco.map.Room;

public class GameContext implements Serializable {
    private static final long serialVersionUID = 1L;
    private static final GameContext instance = new GameContext();

    private Player player;
    private Room currentRoom;
    private int score;
    private final EventManager eventManager = new EventManager();

    private GameContext() {
        // usato solo dal singleton
    }
    
    public static GameContext getInstance() {
        return instance;
    }

    public Player getPlayer() {
        return player;
    }

    public void setPlayer(Player player) {
        this.player = player;
    }

    public Room getCurrentRoom() {
        return currentRoom;
    }

    public void setCurrentRoom(Room currentRoom) {
        this.currentRoom = currentRoom;
    }

    public EventManager getEventManager() {
        return eventManager;
    }

    public void increaseScore(int amount) {
        this.score += amount;
        System.out.println("+" + amount + " punti! Punteggio attuale: " + this.score);
    }

    public int getScore() {
        return score;
    }

    public void copyFrom(GameContext other) {
        this.player = other.player;
        this.currentRoom = other.currentRoom;
        this.score = other.score;
    }

    public GameContext cloneContext() {
        GameContext clone = new GameContext();
        clone.copyFrom(this);
        return clone;
    }
}

//core/gamelogger.java
package manfrinmarco.core;

import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;

public class GameLogger {
    private static final String LOG_FILE = manfrinmarco.config.GameConfig.get("log.file");

    public static void log(String message) {
        try (FileWriter writer = new FileWriter(LOG_FILE, true)) {
            writer.write(LocalDateTime.now() + ": " + message + "\n");
        } catch (IOException e) {
            System.err.println("Errore nel logging: " + e.getMessage());
        }
    }
}

//core/gameStateMemento.java
package manfrinmarco.core;

public class GameStateMemento {
    private final GameContext snapshot;

    public GameStateMemento(GameContext current) {
        this.snapshot = current.cloneContext();
    }

    public GameContext getSnapshot() {
        return snapshot;
    }
}

//entities/aggressivestrategy.java
package manfrinmarco.entities;

import java.util.concurrent.ThreadLocalRandom;

public class AggressiveStrategy implements EnemyStrategy {
    @Override
    public void attack(Enemy enemy, Player player) {
        int damage = ThreadLocalRandom.current().nextInt(10, 21); // 10–20
        System.out.println("Il " + enemy.getName() + " attacca con furia causando " + damage + " danni!");
        player.takeDamage(damage);
    }
}

//entities/defensivestrategy.java
package manfrinmarco.entities;

import java.util.concurrent.ThreadLocalRandom;

public class DefensiveStrategy implements EnemyStrategy {
    @Override
    public void attack(Enemy enemy, Player player) {
        if (enemy.getHealth() < 20) {
            int heal = ThreadLocalRandom.current().nextInt(3, 9); // 3–8
            System.out.println("Il " + enemy.getName() + " si cura di " + heal + " HP!");
            enemy.takeDamage(-heal);
        } else {
            int damage = ThreadLocalRandom.current().nextInt(3, 8); // 3–7
            System.out.println("Il " + enemy.getName() + " colpisce cautamente causando " + damage + " danni.");
            player.takeDamage(damage);
        }
    }
}

//entities/enemy.java
package manfrinmarco.entities;
import manfrinmarco.items.Item;

public class Enemy extends Entity {
    private final EnemyStrategy strategy;

    public Enemy(String name, int health, EnemyStrategy strategy) {
        super(name, health);
        this.strategy = strategy;
    }

    public EnemyStrategy getStrategy() {
        return strategy;
    }

    public void executeStrategy(Player player) {
        strategy.attack(this, player);
    }

    private Item drop;

    public void setDrop(Item drop) {
        this.drop = drop;
    }

    public Item getDrop() {
      return drop;
    }

//entities/enemyfactory.java
// EnemyFactory.java — versione dinamica
package manfrinmarco.entities;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import manfrinmarco.io.ReflectionLoader;

public class EnemyFactory {
    private static final Map<String, Enemy> registry = new HashMap<>();

    static {
        List<Object> loaded = ReflectionLoader.instantiateAnnotated("manfrinmarco.entities.custom");
        for (Object obj : loaded) {
            if (obj instanceof Enemy enemy) {
                String key = enemy.getName().toLowerCase();
                registry.put(key, enemy);
                System.out.println("Enemy registrato: " + key);
            }
        }

        // fallback statici
        registry.put("goblin", new Enemy("Goblin", 30, new AggressiveStrategy()));
        registry.put("skeleton", new Enemy("Scheletro", 25, new DefensiveStrategy()));
        registry.put("ratto", new Enemy("Ratto", 15, new AggressiveStrategy()));
    }

    public static Enemy createEnemy(String type) {
        Enemy base = registry.get(type.toLowerCase());
        if (base == null) throw new IllegalArgumentException("Nemico non trovato: " + type);

        return new Enemy(base.getName(), base.getHealth(), base.getStrategy());
    }
} 

//entities/enemystategy.java
package manfrinmarco.entities;

public interface EnemyStrategy {
    void attack(Enemy enemy, Player player);
}

//entities/entity.java 
package manfrinmarco.entities;

public abstract class Entity {
    protected String name;
    protected int health;

    public Entity(String name, int health) {
        this.name = name;
        this.health = health;
    }

    public String getName() {
        return name;
    }

    public int getHealth() {
        return health;
    }

    public boolean isAlive() {
        return health > 0;
    }

    public void attack(Entity enemy) {
        int baseDamage = 0;
        enemy.takeDamage(baseDamage);
    }

    public void takeDamage(int damage) {
        health = Math.max(0, health - damage);
    }
}

//entities/player.java
package manfrinmarco.entities;

import manfrinmarco.config.GameConfig;
import manfrinmarco.items.Inventory;
import manfrinmarco.items.Item;

public class Player extends Entity {
    private Inventory inventory;
    private Item equippedWeapon;
    private Item equippedArmor;

    public Player(String name, int health) {
        super(name, health);
        this.inventory = new Inventory();
        try {
            this.health = Integer.parseInt(GameConfig.get("player.hp"));
        } catch (NumberFormatException e) {
            System.err.println("Valore di player.hp non valido, uso fallback a 100.");
            this.health = 100;
        }
    }

    @Override
    public void attack(Entity enemy) {
        int baseDamage;
        try {
            baseDamage = Integer.parseInt(GameConfig.get("player.basedamage"));
        } catch (NumberFormatException e) {
            System.err.println("Valore di player.basedamage non valido, uso fallback a 10.");
            baseDamage = 10;
        }
        if (equippedWeapon != null) {
            baseDamage += equippedWeapon.getPower();
        }
        enemy.takeDamage(baseDamage);
    }

    public void heal(int amount) {
        this.health = Math.min(100, this.health + amount);
    }

    public Inventory getInventory() {
        return inventory;
    }

    public void setInventory(Inventory inventory) {
        this.inventory = inventory;
    }

    @Override
    public void takeDamage(int damage) {
        int mitigated = damage;
        if (equippedArmor != null) {
            mitigated = Math.max(0, damage - equippedArmor.getPower());
        }
        super.takeDamage(mitigated);
    }

    public String getStatus() {
        String arma = (equippedWeapon != null) ? equippedWeapon.getName() + " (+" + equippedWeapon.getPower() + ")" : "Nessuna";
        String armatura = (equippedArmor != null) ? equippedArmor.getName() + " (+" + equippedArmor.getPower() + ")" : "Nessuna";
        return String.format("HP: %d | Arma: %s | Armatura: %s", this.health, arma, armatura);
    }

    public void equip(Item item) {
        switch (item.getType()) {
            case WEAPON -> {
                this.equippedWeapon = item;
                System.out.println("Hai equipaggiato l'arma: " + item.getName());
            }
            case ARMOR -> {
                this.equippedArmor = item;
                System.out.println("Hai indossato l'armatura: " + item.getName());
            }
            default -> System.out.println("Questo oggetto non può essere equipaggiato.");
        }
    }
}
    
//entities/customs/... all the classes with @autoload
example:
package manfrinmarco.entities.custom;

import manfrinmarco.annotations.AutoLoad;
import manfrinmarco.entities.DefensiveStrategy;
import manfrinmarco.entities.Enemy;

@AutoLoad
public class Skeleton extends Enemy {
    public Skeleton() {
        super("Scheletro", 20, new DefensiveStrategy());
    }
}


//events/eventListener.java
package manfrinmarco.events;

public interface EventListener {
    void onEvent(GameEvent event);
}

//event/eventManager.java
package manfrinmarco.events;

import java.util.ArrayList;
import java.util.List;

public class EventManager {
    private final List<EventListener> listeners = new ArrayList<>();

    public void subscribe(EventListener listener) {
        listeners.add(listener);
    }

    public void notify(GameEvent event) {
        for (EventListener listener : listeners) {
            listener.onEvent(event);
        }
    }
}

/event/gameevent.java
package manfrinmarco.events;

public class GameEvent {
    private final String type;
    private final String message;

    public GameEvent(String type, String message) {
        this.type = type;
        this.message = message;
    }

    public String getType() {
        return type;
    }

    public String getMessage() {
        return message;
    }
}


//event/ScoreListener
package manfrinmarco.events;

import manfrinmarco.core.GameContext;

public class ScoreListener implements EventListener {
    @Override
    public void onEvent(GameEvent event) {
        if (event.getType().equals("enemy_defeated")) {
            int score = Integer.parseInt(manfrinmarco.config.GameConfig.get("score.enemy.defeated"));
            GameContext.getInstance().increaseScore(score);
        }
    }
}

//io/GameFileManager.java
package manfrinmarco.io;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class GameFileManager {
    private static final String SAVE_FILE = "savegame.dat";

    public static void saveGame(String data) {
        try (FileWriter writer = new FileWriter(SAVE_FILE)) {
            writer.write(data);
            System.out.println("Partita salvata.");
        } catch (IOException e) {
            System.err.println("Errore salvataggio: " + e.getMessage());
        }
    }

    public static String loadGame() {
        try (BufferedReader reader = new BufferedReader(new FileReader(SAVE_FILE))) {
            StringBuilder sb = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                sb.append(line).append("\n");
            }
            System.out.println("Partita caricata.");
            return sb.toString();
        } catch (IOException e) {
            System.err.println("Errore caricamento: " + e.getMessage());
            return null;
        }
    }
}

//io/InputSanitizer.java
package manfrinmarco.io;

public class InputSanitizer {
    public static String clean(String input) {
        return input.replaceAll("[^a-zA-Z0-9\\s]", "");
    }
}

//io/reflectionloader.java
package manfrinmarco.io;

import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

import manfrinmarco.annotations.AutoLoad;

public class ReflectionLoader {
    public static List<Object> instantiateAnnotated(String packageName) {
    List<Object> instances = new ArrayList<>();
    try {
        String path = packageName.replace('.', '/');
        URL root = Thread.currentThread().getContextClassLoader().getResource(path);
        if (root == null) return instances;
        File[] files = new File(root.toURI()).listFiles();
        if (files == null) return instances;

        for (File file : files) {
            if (file.getName().endsWith(".class")) {
                String className = packageName + '.' + file.getName().replace(".class", "");
                Class<?> cls = Class.forName(className);
                if (cls.isAnnotationPresent(AutoLoad.class)) {
                    Object obj = cls.getDeclaredConstructor().newInstance();
                    instances.add(obj);
                }
            }
        }
    } catch (Exception e) {
        System.err.println("Errore durante il caricamento dinamico: " + e.getMessage());
    }
    return instances;
}
}

//items/compositeitem.java
package manfrinmarco.items;

import java.util.ArrayList;
import java.util.List;

public class CompositeItem extends Item {
    private final List<Item> components = new ArrayList<>();

    public CompositeItem(String name) {
        super(name, ItemType.WEAPON);
    }

    public void addItem(Item item) {
        components.add(item);
    }

    public List<Item> getComponents() {
        return components;
    }

    public void setPower(int power) {
    this.power = power;
}
}

//items/inventory.java
package manfrinmarco.items;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Inventory implements Iterable<Item> {
    private final List<Item> items = new ArrayList<>();

    public void addItem(Item item) {
        items.add(item);
    }

    public void removeItem(Item item) {
        items.remove(item);
    }

    @Override
    public Iterator<Item> iterator() {
        return items.iterator();
    }
}

//items/item.java
package manfrinmarco.items;

public class Item {
    protected String name;
    protected ItemType type;
    protected int power;

    public Item(String name, ItemType type) {
        this.name = name;
        this.type = type;
    }

    public Item(String name, ItemType type, int power) {
        this.name = name;
        this.type = type;
        this.power = power;
    }

    @Override
    public String toString() {
        return name + " (" + type + (power > 0 ? ", +" + power : "") + ")";
    }

    public String getName() {
        return name;
    }

    public ItemType getType() {
        return type;
    }

    public int getPower() {
        return power;
    }
}

//items/itembuilder.java
package manfrinmarco.items;

public class ItemBuilder {
    private String name;
    private ItemType type;
    private int power;

    public ItemBuilder setName(String name) {
        this.name = name;
        return this;
    }

    public ItemBuilder setType(ItemType type) {
        this.type = type;
        return this;
    }

    public ItemBuilder setPower(int power) {
        this.power = power;
        return this;
    }

    public Item build() {
        return new Item(name, type, power);
    }
}

//items/itemtype.java
package manfrinmarco.items;

public enum ItemType {
    WEAPON,
    ARMOR,
    POTION,
    KEY,
    TOOL
}

//items/itemfacory.java
package manfrinmarco.items;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import manfrinmarco.io.ReflectionLoader;

public class ItemFactory {
    private static final Map<String, ItemTemplate> registry = new HashMap<>();
    private static boolean initialized = false;

    private static void initIfNeeded() {
        if (initialized) return;
        List<Object> templates = ReflectionLoader.instantiateAnnotated("manfrinmarco.items.special");
        for (Object obj : templates) {
            if (obj instanceof ItemTemplate template) {
                registry.put(template.getId().toLowerCase(), template);
                System.out.println("Item registrato: " + template.getId());
            }
        }
        initialized = true;
    }

    public static Item create(String id) {
        initIfNeeded();
        ItemTemplate template = registry.get(id.toLowerCase());
        if (template == null) throw new IllegalArgumentException("Item non trovato: " + id);
        return template.create();
    }
}

//items/itemtemplate.java
package manfrinmarco.items;

public interface ItemTemplate {
    Item create();
    String getId(); // es: "spada", "pozione", ecc.
}

//items/special//... all items with @autoload
example:
package manfrinmarco.items.special;

import manfrinmarco.annotations.AutoLoad;
import manfrinmarco.items.Item;
import manfrinmarco.items.ItemBuilder;
import manfrinmarco.items.ItemTemplate;
import manfrinmarco.items.ItemType;

@AutoLoad
public class TorciaMagica implements ItemTemplate {
    @Override
    public Item create() {
        return new ItemBuilder()
                .setName("Torcia Magica")
                .setType(ItemType.TOOL)
                .setPower(0)
                .build();
    }

    @Override
    public String getId() {
        return "torciam";
    }
}


//map/compositeroom.java
package manfrinmarco.map;

import java.util.ArrayList;
import java.util.List;

public class CompositeRoom extends Room {
    private final List<Room> subRooms = new ArrayList<>();

    public CompositeRoom(String name, String description) {
        super(name, description);
    }

    public void addRoom(Room room) {
        subRooms.add(room);
    }

    private Room mainRoom;

    public void setMainRoom(Room room) {
        this.mainRoom = room;
    }

    public Room getMainRoom() {
        return mainRoom;
    }

    public List<Room> getSubRooms() {
        return subRooms;
    }
}

//map/direction
package manfrinmarco.map;

public enum Direction {
    NORTH, SOUTH, EAST, WEST;
}

//map/room.java
package manfrinmarco.map;

import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;

import manfrinmarco.entities.Enemy;
import manfrinmarco.items.Item;

public class Room {
    protected String name;
    protected String description;
    protected Map<Direction, Room> exits = new EnumMap<>(Direction.class);
    protected Enemy enemy;
    protected List<Item> items = new ArrayList<>();
    protected boolean locked = false;
    protected Item keyRequired;

    public Room(String name, String description) {
        this.name = name;
        this.description = description;
    }

    public void setExit(Direction direction, Room room) {
        exits.put(direction, room);
    }

    public Room getExit(Direction direction) {
        return exits.get(direction);
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public Enemy getEnemy() {
        return enemy;
    }

    public void setEnemy(Enemy enemy) {
        this.enemy = enemy;
    }

    public void addItem(Item item) {
        items.add(item);
    }

    public void removeItem(Item item) {
        items.remove(item);
    }

    public List<Item> getItems() {
        return items;
    }

    public boolean isLocked() {
        return locked;
    }

    public void setLocked(boolean locked, Item keyRequired) {
        this.locked = locked;
        this.keyRequired = keyRequired;
    }

    public boolean unlock(Item key) {
        if (locked && keyRequired != null && key.getName().equalsIgnoreCase(keyRequired.getName())) {
            locked = false;
            return true;
        }
        return false;
    }
}

//map/roomfactory.java
package manfrinmarco.map;

public class RoomFactory {
    public static Room createRoom(String type) {
        return switch (type.toLowerCase()) {
            case "corridoio" -> new Room("Corridoio", "Un lungo corridoio buio.");
            case "cella" -> new Room("Cella", "Una piccola cella abbandonata.");
            case "entrata" -> new Room("Entrata", "L'ingresso del castello.");
            case "sala" -> new Room("Sala del Trono", "La grande sala del trono.");
            case "armeria" -> new Room("Armeria Oscura", "Contiene armi abbandonate.");
            case "cripta" -> new Room("Cripta", "Una cripta buia e fredda.");
            default -> new Room("Stanza misteriosa", "Non riesci a distinguere nulla.");
        };
    }
}

//map/roomiterator.java
package manfrinmarco.map;

import java.util.Iterator;
import java.util.List;

public class RoomIterator implements Iterator<Room> {
    private final Iterator<Room> iterator;

    public RoomIterator(List<Room> rooms) {
        this.iterator = rooms.iterator();
    }

    @Override
    public boolean hasNext() {
        return iterator.hasNext();
    }

    @Override
    public Room next() {
        return iterator.next();
    }
}

//security/gameException.java
package manfrinmarco.security;

public class GameException extends RuntimeException {
    public GameException(String message) {
        super(message);
    }
}

//main.java
package manfrinmarco;

import manfrinmarco.core.Game;

public class Main {
    public static void main(String[] args) {
        Game game = new Game();
        game.start();
    }
}

//game.properties
# --------------------------
# Configurazione Giocatore
# --------------------------
player.hp=100
player.baseDamage=10

# --------------------------
# Oggetti
# --------------------------
item.potion.healAmount=20

# --------------------------
# Logging
# --------------------------
log.file=game.log

# --------------------------
# Punteggio
# --------------------------
score.enemy.defeated=100